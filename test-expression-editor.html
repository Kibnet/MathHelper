<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Expression Editor Tests</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    .test-container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      color: #38bdf8;
      margin-bottom: 30px;
    }
    .test-suite {
      background: #16213e;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .test-suite h2 {
      color: #22c55e;
      margin-top: 0;
    }
    .test-case {
      background: #0f172a;
      border-left: 4px solid #38bdf8;
      padding: 15px;
      margin: 10px 0;
      border-radius: 4px;
    }
    .test-case.pass {
      border-left-color: #22c55e;
    }
    .test-case.fail {
      border-left-color: #ef4444;
    }
    .test-name {
      font-weight: 600;
      margin-bottom: 8px;
    }
    .test-status {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
      margin-left: 10px;
    }
    .test-status.pass {
      background: #22c55e;
      color: #000;
    }
    .test-status.fail {
      background: #ef4444;
      color: #fff;
    }
    .test-details {
      color: #94a3b8;
      font-size: 0.9rem;
      margin-top: 8px;
    }
    .test-error {
      color: #ef4444;
      font-family: monospace;
      background: rgba(239, 68, 68, 0.1);
      padding: 8px;
      border-radius: 4px;
      margin-top: 8px;
    }
    .summary {
      background: #1e293b;
      padding: 20px;
      border-radius: 8px;
      margin-top: 30px;
      display: flex;
      justify-content: space-around;
      text-align: center;
    }
    .summary-item {
      flex: 1;
    }
    .summary-value {
      font-size: 2rem;
      font-weight: 700;
      margin: 10px 0;
    }
    .summary-label {
      color: #94a3b8;
      font-size: 0.9rem;
    }
    pre {
      background: #0f172a;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <div class="test-container">
    <h1>ðŸ§ª Expression Editor Test Suite</h1>
    <div id="testResults"></div>
    <div class="summary" id="summary"></div>
  </div>

  <script>
    // Copy necessary functions from expression-editor.html
    let nodeIdCounter = 0;

    function generateId() {
      return `node_${nodeIdCounter++}`;
    }

    class ExpressionParser {
      constructor(input) {
        this.input = input.replace(/\s+/g, '');
        this.pos = 0;
      }

      parse() {
        if (!this.input) throw new Error('Empty expression');
        const result = this.parseExpression();
        if (this.pos < this.input.length) {
          throw new Error(`Unexpected character at position ${this.pos}: ${this.input[this.pos]}`);
        }
        return result;
      }

      parseExpression() {
        return this.parseAdditive();
      }

      parseAdditive() {
        let left = this.parseMultiplicative();
        
        while (this.pos < this.input.length && (this.peek() === '+' || this.peek() === '-')) {
          const op = this.consume();
          const right = this.parseMultiplicative();
          left = {
            id: generateId(),
            type: 'operator',
            value: op,
            children: [left, right]
          };
        }
        
        return left;
      }

      parseMultiplicative() {
        let left = this.parseUnary();
        
        while (this.pos < this.input.length && (this.peek() === '*' || this.peek() === '/')) {
          const op = this.consume();
          const right = this.parseUnary();
          left = {
            id: generateId(),
            type: 'operator',
            value: op,
            children: [left, right]
          };
        }
        
        return left;
      }

      parseUnary() {
        if (this.peek() === '-') {
          this.consume();
          const operand = this.parseUnary();
          return {
            id: generateId(),
            type: 'unary',
            value: '-',
            children: [operand]
          };
        }
        return this.parsePrimary();
      }

      parsePrimary() {
        if (this.peek() === '(') {
          this.consume();
          const expr = this.parseExpression();
          if (this.peek() !== ')') {
            throw new Error('Missing closing parenthesis');
          }
          this.consume();
          return {
            id: generateId(),
            type: 'group',
            value: 'group',
            children: [expr]
          };
        }

        if (this.isDigit(this.peek())) {
          return this.parseNumber();
        }

        if (this.isLetter(this.peek())) {
          return this.parseVariable();
        }

        throw new Error(`Unexpected character: ${this.peek()}`);
      }

      parseNumber() {
        let num = '';
        while (this.pos < this.input.length && (this.isDigit(this.peek()) || this.peek() === '.')) {
          num += this.consume();
        }
        return {
          id: generateId(),
          type: 'constant',
          value: parseFloat(num)
        };
      }

      parseVariable() {
        let name = '';
        while (this.pos < this.input.length && this.isLetter(this.peek())) {
          name += this.consume();
        }
        return {
          id: generateId(),
          type: 'variable',
          value: name
        };
      }

      peek() {
        return this.input[this.pos];
      }

      consume() {
        return this.input[this.pos++];
      }

      isDigit(char) {
        return char && /[0-9]/.test(char);
      }

      isLetter(char) {
        return char && /[a-zA-Z]/.test(char);
      }
    }

    function expressionToString(node) {
      if (!node) return '';
      
      if (node.type === 'constant') {
        return String(node.value);
      } else if (node.type === 'variable') {
        return node.value;
      } else if (node.type === 'unary') {
        return '-' + expressionToString(node.children[0]);
      } else if (node.type === 'group') {
        return '(' + expressionToString(node.children[0]) + ')';
      } else if (node.type === 'operator') {
        const left = expressionToString(node.children[0]);
        const right = expressionToString(node.children[1]);
        return left + ' ' + node.value + ' ' + right;
      }
      return '';
    }

    // Simplified rule checking
    function hasApplicableRules(node) {
      if (!node) return false;
      
      // Check for various transformation types
      if (node.type === 'constant' || node.type === 'variable') {
        return true; // Can always wrap
      }
      
      if (node.type === 'operator') {
        // Check for evaluation
        if (node.children && node.children[0].type === 'constant' && node.children[1].type === 'constant') {
          return true;
        }
        // Check for simplification (e.g., *1, +0)
        if (node.value === '*' && node.children) {
          if ((node.children[0].type === 'constant' && node.children[0].value === 1) ||
              (node.children[1].type === 'constant' && node.children[1].value === 1)) {
            return true;
          }
        }
        return true; // Operators usually have commutative, distributive, etc.
      }
      
      return true;
    }

    function findAllSubexpressions(exprString) {
      const subexpressions = [];
      const length = exprString.length;
      
      for (let start = 0; start < length; start++) {
        for (let end = start + 1; end <= length; end++) {
          const substring = exprString.substring(start, end);
          const trimmedSubstring = substring.trim();
          
          if (!trimmedSubstring) continue;
          if (substring !== trimmedSubstring) continue;
          
          // Skip individual digits that are part of a larger number
          if (/^\d$/.test(trimmedSubstring)) {
            const charBefore = start > 0 ? exprString[start - 1] : '';
            const charAfter = end < length ? exprString[end] : '';
            if (/\d/.test(charBefore) || /\d/.test(charAfter)) {
              continue;
            }
          }
          
          try {
            const parser = new ExpressionParser(trimmedSubstring);
            const node = parser.parse();
            
            if (node && hasApplicableRules(node)) {
              subexpressions.push({
                text: trimmedSubstring,
                start: start,
                end: end,
                node: node,
                length: end - start
              });
            }
          } catch (e) {
            // Skip invalid expressions
          }
        }
      }
      
      // Remove duplicates
      const uniqueSubexpressions = [];
      const seen = new Set();
      
      for (const subexpr of subexpressions) {
        const key = `${subexpr.start}-${subexpr.end}`;
        if (!seen.has(key)) {
          seen.add(key);
          uniqueSubexpressions.push(subexpr);
        }
      }
      
      return uniqueSubexpressions;
    }

    // Test framework
    class TestRunner {
      constructor() {
        this.tests = [];
        this.results = [];
      }

      describe(suiteName, callback) {
        const suite = { name: suiteName, tests: [] };
        this.currentSuite = suite;
        callback();
        this.tests.push(suite);
        this.currentSuite = null;
      }

      it(testName, testFn) {
        if (!this.currentSuite) {
          throw new Error('Test must be inside a describe block');
        }
        this.currentSuite.tests.push({ name: testName, fn: testFn });
      }

      expect(actual) {
        return {
          toBe: (expected) => {
            if (actual !== expected) {
              throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
            }
          },
          toEqual: (expected) => {
            if (JSON.stringify(actual) !== JSON.stringify(expected)) {
              throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
            }
          },
          toContain: (expected) => {
            if (!actual.includes(expected)) {
              throw new Error(`Expected array to contain ${JSON.stringify(expected)}`);
            }
          },
          toHaveLength: (expected) => {
            if (actual.length !== expected) {
              throw new Error(`Expected length ${expected}, but got ${actual.length}`);
            }
          },
          toBeGreaterThan: (expected) => {
            if (actual <= expected) {
              throw new Error(`Expected ${actual} to be greater than ${expected}`);
            }
          },
          toBeTruthy: () => {
            if (!actual) {
              throw new Error(`Expected value to be truthy, but got ${actual}`);
            }
          },
          toThrow: () => {
            try {
              actual();
              throw new Error('Expected function to throw an error');
            } catch (e) {
              // Expected
            }
          }
        };
      }

      async run() {
        this.results = [];
        const resultsDiv = document.getElementById('testResults');
        resultsDiv.innerHTML = '';

        for (const suite of this.tests) {
          const suiteDiv = document.createElement('div');
          suiteDiv.className = 'test-suite';
          
          const suiteTitle = document.createElement('h2');
          suiteTitle.textContent = suite.name;
          suiteDiv.appendChild(suiteTitle);

          for (const test of suite.tests) {
            const testDiv = document.createElement('div');
            testDiv.className = 'test-case';
            
            const testName = document.createElement('div');
            testName.className = 'test-name';
            testName.textContent = test.name;
            
            let passed = false;
            let error = null;
            
            try {
              test.fn.call(this);
              passed = true;
            } catch (e) {
              error = e.message;
            }

            const status = document.createElement('span');
            status.className = `test-status ${passed ? 'pass' : 'fail'}`;
            status.textContent = passed ? 'âœ“ PASS' : 'âœ— FAIL';
            testName.appendChild(status);
            
            testDiv.appendChild(testName);
            
            if (error) {
              const errorDiv = document.createElement('div');
              errorDiv.className = 'test-error';
              errorDiv.textContent = error;
              testDiv.appendChild(errorDiv);
            }

            testDiv.classList.add(passed ? 'pass' : 'fail');
            suiteDiv.appendChild(testDiv);
            
            this.results.push({ suite: suite.name, test: test.name, passed, error });
          }

          resultsDiv.appendChild(suiteDiv);
        }

        this.showSummary();
      }

      showSummary() {
        const total = this.results.length;
        const passed = this.results.filter(r => r.passed).length;
        const failed = total - passed;

        const summaryDiv = document.getElementById('summary');
        summaryDiv.innerHTML = `
          <div class="summary-item">
            <div class="summary-label">Total Tests</div>
            <div class="summary-value" style="color: #38bdf8;">${total}</div>
          </div>
          <div class="summary-item">
            <div class="summary-label">Passed</div>
            <div class="summary-value" style="color: #22c55e;">${passed}</div>
          </div>
          <div class="summary-item">
            <div class="summary-label">Failed</div>
            <div class="summary-value" style="color: #ef4444;">${failed}</div>
          </div>
          <div class="summary-item">
            <div class="summary-label">Success Rate</div>
            <div class="summary-value" style="color: ${failed === 0 ? '#22c55e' : '#f59e0b'};">${((passed/total) * 100).toFixed(1)}%</div>
          </div>
        `;
      }
    }

    // Run tests
    const runner = new TestRunner();

    // Test Suite 1: Expression Parsing
    runner.describe('Expression Parsing', function() {
      this.it('should parse simple number', function() {
        const parser = new ExpressionParser('123');
        const result = parser.parse();
        this.expect(result.type).toBe('constant');
        this.expect(result.value).toBe(123);
      });

      this.it('should parse variable', function() {
        const parser = new ExpressionParser('x');
        const result = parser.parse();
        this.expect(result.type).toBe('variable');
        this.expect(result.value).toBe('x');
      });

      this.it('should parse addition', function() {
        const parser = new ExpressionParser('2 + 3');
        const result = parser.parse();
        this.expect(result.type).toBe('operator');
        this.expect(result.value).toBe('+');
      });

      this.it('should parse complex expression', function() {
        const parser = new ExpressionParser('2 + 3 * 4');
        const result = parser.parse();
        this.expect(result.type).toBe('operator');
        this.expect(result.value).toBe('+');
        this.expect(result.children[1].value).toBe('*');
      });

      this.it('should parse parentheses', function() {
        const parser = new ExpressionParser('(2 + 3)');
        const result = parser.parse();
        this.expect(result.type).toBe('group');
      });

      this.it('should throw on invalid expression', function() {
        this.expect(() => new ExpressionParser('2 +').parse()).toThrow();
      });
    });

    // Test Suite 2: Frame Generation
    runner.describe('Frame Generation', function() {
      this.it('should find frames in simple expression', function() {
        const frames = findAllSubexpressions('2 + 3');
        this.expect(frames.length).toBeGreaterThan(0);
      });

      this.it('should treat consecutive digits as one frame', function() {
        const frames = findAllSubexpressions('123');
        const digitFrames = frames.filter(f => /^\d+$/.test(f.text));
        this.expect(digitFrames.length).toBe(1);
        this.expect(digitFrames[0].text).toBe('123');
      });

      this.it('should not create frame for middle digit in number', function() {
        const frames = findAllSubexpressions('123');
        const singleDigitFrames = frames.filter(f => f.text === '2');
        this.expect(singleDigitFrames.length).toBe(0);
      });

      this.it('should find nested expressions', function() {
        const frames = findAllSubexpressions('a + 2 + 3');
        const texts = frames.map(f => f.text);
        this.expect(texts).toContain('a');
        this.expect(texts).toContain('2');
        this.expect(texts).toContain('3');
      });

      this.it('should handle expressions with parentheses', function() {
        const frames = findAllSubexpressions('(2 + 3)');
        this.expect(frames.length).toBeGreaterThan(0);
      });

      this.it('should not create frames for invalid expressions', function() {
        const frames = findAllSubexpressions('2 +');
        // Should only find '2', not '2 +'
        const invalidFrames = frames.filter(f => f.text === '2 +');
        this.expect(invalidFrames.length).toBe(0);
      });
    });

    // Test Suite 3: Frame Positioning
    runner.describe('Frame Positioning', function() {
      this.it('should calculate correct start position', function() {
        const frames = findAllSubexpressions('a + 2');
        const frameA = frames.find(f => f.text === 'a');
        this.expect(frameA.start).toBe(0);
      });

      this.it('should calculate correct end position', function() {
        const frames = findAllSubexpressions('a + 2');
        const frameA = frames.find(f => f.text === 'a');
        this.expect(frameA.end).toBe(1);
      });

      this.it('should handle spaces correctly', function() {
        const frames = findAllSubexpressions('a + 2');
        const frame2 = frames.find(f => f.text === '2');
        this.expect(frame2.start).toBe(4);
      });

      this.it('should find overlapping frames', function() {
        const frames = findAllSubexpressions('2 + 3');
        // Should have: '2', '3', '2 + 3'
        this.expect(frames.length).toBeGreaterThan(2);
      });
    });

    // Test Suite 4: Rule Application
    runner.describe('Rule Application', function() {
      this.it('should detect rules for constants', function() {
        const parser = new ExpressionParser('5');
        const node = parser.parse();
        const hasRules = hasApplicableRules(node);
        this.expect(hasRules).toBeTruthy();
      });

      this.it('should detect rules for variables', function() {
        const parser = new ExpressionParser('x');
        const node = parser.parse();
        const hasRules = hasApplicableRules(node);
        this.expect(hasRules).toBeTruthy();
      });

      this.it('should detect evaluation rules for constant operations', function() {
        const parser = new ExpressionParser('2 + 3');
        const node = parser.parse();
        const hasRules = hasApplicableRules(node);
        this.expect(hasRules).toBeTruthy();
      });

      this.it('should detect simplification rules', function() {
        const parser = new ExpressionParser('x * 1');
        const node = parser.parse();
        const hasRules = hasApplicableRules(node);
        this.expect(hasRules).toBeTruthy();
      });
    });

    // Test Suite 5: Expression String Conversion
    runner.describe('Expression String Conversion', function() {
      this.it('should convert constant to string', function() {
        const parser = new ExpressionParser('42');
        const node = parser.parse();
        const str = expressionToString(node);
        this.expect(str).toBe('42');
      });

      this.it('should convert variable to string', function() {
        const parser = new ExpressionParser('abc');
        const node = parser.parse();
        const str = expressionToString(node);
        this.expect(str).toBe('abc');
      });

      this.it('should convert operation to string', function() {
        const parser = new ExpressionParser('2+3');
        const node = parser.parse();
        const str = expressionToString(node);
        this.expect(str).toBe('2 + 3');
      });

      this.it('should convert parentheses to string', function() {
        const parser = new ExpressionParser('(a+b)');
        const node = parser.parse();
        const str = expressionToString(node);
        this.expect(str).toBe('(a + b)');
      });
    });

    // Run all tests
    runner.run();
  </script>
</body>
</html>
