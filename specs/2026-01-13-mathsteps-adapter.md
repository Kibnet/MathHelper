# Внедрение mathsteps (Kibnet) через адаптер MathStepsEngine

## 0. Метаданные
- Тип (профиль): Архитектурный рефакторинг
- Владелец: команда MathHelper
- Масштаб: medium
- Целевой релиз / ветка: текущая ветка
- Ограничения: сохранить существующий парсер и UI-структуру; использовать mathsteps (Kibnet) для трансформаций; не менять поведение без согласования
- Связанные ссылки: https://github.com/Kibnet/mathsteps

## 1. Overview / Цель
Добавить адаптер MathStepsEngine, который использует mathsteps (Kibnet) для списка доступных преобразований и применения трансформаций к выбранному подвыражению, сохраняя текущий парсер/AST и UI (фреймы/подвыражения).

## 2. Текущее состояние (AS-IS)
- Парсер: `ExpressionParser` строит собственный AST; позиции узлов определяются по строке через `expressionToString` и `indexOf`. Точки клика в UI привязаны к узлам AST. 
- Трансформации: сейчас список правил формируется в `getApplicableRules` (custom), применение — через `rule.apply`.
- UI: при клике на фрейм в `ExpressionDisplay` подвыражение и правила передаются в `CommandPanel`, которая отображает список.
- Ограничение: нет прямого соответствия между узлом нашего AST и узлом mathsteps/mathjs AST.

## 3. Проблема
Нужно подключить mathsteps для вычисления применимых трансформаций и их применения к выбранному пользователем подвыражению, сохранив текущую схему AST и визуальных фреймов.

## 4. Цели дизайна
- Разделение ответственности: адаптер изолирует работу с mathsteps.
- Повторное использование: единый MathStepsEngine для списка и применения операций.
- Тестируемость: отдельные unit-тесты для конвертации пути и применения трансформаций.
- Консистентность: UI продолжает работать с текущим AST/строкой выражения.
- Обратная совместимость: существующие сценарии должны продолжить работать (если нужно — fallback на текущие правила).
- Оценить целесообразность перехода на парсер/AST библиотеки и влияние на UI.

## 5. Non-Goals (чего НЕ делаем)
- Не переписываем текущий парсер/AST и визуальную разметку фреймов.
- Не внедряем решение уравнений (solveEquation) и факторизацию.
- Не меняем математику/лексер текущего парсера.

## 6. Предлагаемое решение (TO-BE)
### 6.1 Распределение ответственности
| Компонент | Ответственность | Входы | Выходы |
|---|---|---|---|
| MathStepsEngine | Адаптер к mathsteps: list/apply, преобразование пути | exprString, selection (AST/строка) | список операций, новый узел mathsteps (через preview) |
| UI (ExpressionEditorApp/CommandPanel) | Отображение и инициирование действий | выбранный фрейм | вызов MathStepsEngine и отображение результата |
| Analyzer/ExpressionDisplay | Определение подвыражений и их позиции | AST, строка | список фреймов |

**Схема зависимостей (TO-BE):**
```
UI (ExpressionEditorApp/CommandPanel)
        |
        v
  MathStepsEngine  --->  mathsteps (Kibnet)
        |
        v
ExpressionParser / AST (наш)
```
### 6.2 Детальный дизайн
**Публичный API (новый):**
- `MathStepsEngine.parse(expr: string): ASTNode` — вызывает существующий `ExpressionParser`.
- `MathStepsEngine.toMathStepsPath(selection): string[]` — конвертер пути из selection → mathsteps path (`['args', index, 'content', ...]`).
- `MathStepsEngine.listOps(expr: string, selection): ApplicableTransform[]` — вызывает `listApplicableTransforms` из mathsteps.
- `MathStepsEngine.apply(expr: string, selection, opId: string): NodeStatus` — вызывает `applyTransform` из mathsteps.

**Конвертация пути (ключевая часть):**
- Вход selection: текущий узел AST + `subexprString` (строка подвыражения), известная на момент клика.
- Выход: путь в mathjs-дереве (формат `args/index/content` как в mathsteps).
- Алгоритм (предлагаемый базовый):
  1. Получить mathjs AST через mathsteps.normalizeExpressionString + mathjs.parse.
  2. Обойти mathjs AST в глубину и построить список `{path, node, signature}`.
  3. Для узлов вычислить signature = `print.ascii(node)` (из mathsteps).
  4. Фильтрация кандидатов: `signature === subexprString`.
  5. При нескольких совпадениях — применить структурные эвристики (например, сравнение типа узла, количества аргументов, наличие `content`), при необходимости использовать ближайший к центру диапазона токенов (если будут вычислены позиции).

**Ошибки и деградация:**
- Если `toMathStepsPath` не может однозначно определить путь — вернуть ошибку с кодом (например, `SELECTION_AMBIGUOUS`) и показывать «Нет доступных преобразований». Fallback на старые правила не используется.

**Производительность:**
- Для каждой операции клика достаточно одного обхода mathjs AST.
- Для списка фреймов лучше вычислять операции по запросу (onClick), чтобы не обходить дерево на каждый узел.

### 6.3 Выбранный вариант реализации
**Вариант D (перейти на парсер/AST библиотеки mathsteps/mathjs):**
- Использовать mathjs AST как основной, а наш парсер оставить только для legacy или убрать из UI потока.
- Фреймы строить по mathjs AST (переопределить `ExpressionDisplay`/`analyzer`).
  - Плюсы: нативные пути для `listApplicableTransforms`/`applyTransform`, меньше адаптаций.
  - Минусы: значительная переработка UI и фреймов, требуется новая логика позиций/токенов, возможны расхождения формата вывода и поведения.

## 7. Бизнес-правила / Алгоритмы (если есть)
- Преобразования и правила определяются mathsteps (Kibnet), принимаются как «источник истины». 
- При совпадении нескольких узлов по строке — использовать детерминированный выбор (по структуре) для стабильности интерфейса.

## 8. Точки интеграции и триггеры
- `ExpressionEditorApp` при клике на фрейм запрашивает `MathStepsEngine.listOps` и отображает операции.
- При выборе операции UI вызывает `MathStepsEngine.apply` и обновляет выражение.

## 9. Изменения модели данных / состояния
- Введём тип `ApplicableTransform` (обёртка над mathsteps). 
- Дополнительно хранить `selectionPath` и `opId` в контексте UI (если потребуется для применения).

## 10. Миграция / Rollout / Rollback
- Миграция: добавить mathsteps (форк Kibnet) как зависимость и переключить UI на MathStepsEngine.
- Rollback: переключить UI на старый `getApplicableRules` и `rule.apply` (сохранить код до перехода или оставить feature-flag).

## 11. Тестирование и критерии приёмки
**Acceptance Criteria:**
- Пользователь видит список преобразований из mathsteps при клике по фрейму.
- Применение преобразования обновляет выражение и историю, без ошибок.
- Ошибки неверного пути обрабатываются корректно (сообщение пользователю или fallback).
- Если выбран вариант D: фреймы корректно строятся на базе mathjs AST и совпадают с визуальным выделением подстрок.

**Тесты:**
- Unit-тесты для `toMathStepsPath` (уникальные и неоднозначные случаи).
- Unit-тесты для `listOps` и `apply` (соответствие `preview.newNode`).
- Регрессионные тесты для UI сценария выбора и применения операции.

**Команды проверки:**
- `npm run test:run`
- `npm run coverage`
- `npm run build`
- `npm run test:e2e` (если изменится UI)

## 12. Риски и edge cases
- Дубликаты подвыражений в строке → неправильный узел в mathjs AST.
- Различия строкового вывода между нашим `expressionToString` и `print.ascii` mathsteps.
- Скрытые унарные минусы и implicit multiplication в нашем AST могут не совпасть с mathsteps печатью.

## 13. План выполнения
1. Спроектировать переход на mathjs AST в UI и analyzer.
2. Добавить mathsteps (Kibnet) как зависимость и обёртку MathStepsEngine.
3. Реализовать построение фреймов по mathjs AST и тесты.
4. Переключить UI на новую логику list/apply.
5. Обновить/добавить тесты (unit + UI).
6. Прогнать тесты и линтеры по чеклисту.

## 14. Открытые вопросы
Открытых вопросов нет.

## 15. Результат прогона линтера
- [PASS] 1. Есть чёткая цель.
- [PASS] 2. Описано текущее состояние (AS-IS).
- [PASS] 3. Сформулирована одна проблема.
- [PASS] 4. Цели дизайна ограничивают решение.
- [PASS] 5. Non-Goals заданы явно.
- [PASS] 6. Есть распределение ответственности.
- [PASS] 7. Явно указаны точки интеграции.
- [PARTIAL] 8. Бизнес-логика формализована (если есть). (Есть общие правила, но детали matching требуют уточнения в реализации.)
- [PASS] 9. Описана обработка ошибок.
- [PASS] 10. Учтена производительность (если релевантно).
- [PASS] 11. Описаны изменения модели данных.
- [PASS] 12. Есть план миграции.
- [PASS] 13. Учтена обратная совместимость / откат.
- [PASS] 14. Есть измеримые критерии приёмки.
- [PASS] 15. Есть план тестирования.
- [PASS] 16. Есть команды для проверки.
- [PASS] 17. Есть пошаговый план.
- [PASS] 18. Нет блокирующих открытых вопросов.
- [PASS] 19. Масштаб задачи соответствует глубине спеки.
- [PASS] 20. Выполнены требования выбранного профиля.

## Approval
Ожидается фраза: "Спеку подтверждаю"
