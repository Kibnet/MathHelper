# Ревизия и расширение набора операций (MathSteps + детерминированный рендер)

## 0. Метаданные
- Тип (профиль): Проектирование подсистемы
- Владелец: команда MathHelper
- Масштаб: large
- Целевой релиз / ветка: текущая ветка
- Ограничения: не писать код до утверждения спеки; использовать существующие файлы проекта (без создания новых) если пользователь явно не разрешит; показывать выражения «как в учебнике», ввод — в техническом виде
- Связанные ссылки: https://github.com/Kibnet/mathsteps

## 1. Overview / Цель
Сделать максимально гибкий, детерминированный и эквивалентный набор преобразований выражений и уравнений в UI, с полным покрытием операций mathsteps (simplify + solve) и корректным визуальным рендером «как в учебнике». Операции показываются одним списком (без разделения на режимы), с автоматическим отбором применимых шагов. Выбор операций — по категориям, без разделения на «простые/сложные».

## 2. Текущее состояние (AS-IS)
- Источник операций: `MathStepsEngine.listOps` → `mathsteps.applicableTransforms.listApplicableTransforms` (домен simplify) (`src/core/mathsteps-engine.ts`).
- UI строит фреймы по mathsteps AST, но позиции вычисляет на основе исходной строки/токенов (`src/ui/components/ExpressionDisplay.ts`).
- Токенизатор поддерживает только `+ - * /`, скобки, числа и однобуквенные переменные (`src/utils/tokenizer.ts`).
- Сортировка операций в панели группирует по `searcher` (техническое имя) (`src/ui/components/CommandPanel.ts`).
- Решение уравнений (solve domain) не включено.

## 3. Проблема
Текущая модель рендера и токенизации не покрывает полный синтаксис mathsteps (степени, функции, корни, много-буквенные идентификаторы), из‑за чего часть операций недоступна или отображается некорректно. Также отсутствуют операции solve в UI, а сортировка операций не соответствует предметным категориям.

## 4. Цели дизайна
- Полное покрытие операций mathsteps (simplify + solve) без ручного фильтра по сложности.
- Один список операций без переключения режимов; операции вычисляются автоматически из simplify + solve.
- Детерминированный список операций: стабильный порядок и воспроизводимое поведение.
- Рендер выражений «как в учебнике» (2x, x², √x, |x|, функции с нормальной записью).
- Ввод/редактирование — в техническом формате (mathjs‑совместимая строка).
- Одинаковая эквивалентность выражений до/после для simplify, и корректные допустимые преобразования для solve.

## 5. Non-Goals (чего НЕ делаем)
- Не внедряем нестабильные или непроверяемые преобразования вне mathsteps.
- Не делаем автоматическое применение правил без выбора пользователя.
- Не делаем режимы «простое/сложное» или ограничение по возрасту (все операции доступны).
- Не меняем локализацию UI (остаётся русский язык).

## 6. Предлагаемое решение (TO-BE)

### 6.1 Архитектура (вариант C)
Переходим на детерминированный рендер выражения по AST, без вычисления позиций по строке.

Компоненты:
- `MathStepsEngine`
  - Собирает операции из simplify и solve, объединяет операции без дедупликации.
  - Возвращает операции с категорией, описанием (RU), упорядоченным индексом и метаданными.
- `ExpressionDisplay`
  - Рендерит выражение из AST в DOM‑дерево токенов.
  - Строит фреймы по DOM‑границам узлов AST (через `getBoundingClientRect`).
- `CommandPanel`
  - Группирует операции по предметным категориям (а не по `searcher`).
- `ExpressionEditorApp`
  - Добавляет отображение описаний операций (RU) в панели команд.

### 6.2 Публичный API
`MathStepsEngine` (расширение):
- `parse(expression: string): MathStepsNode` — без изменений, основа для рендера.
- `listOps(expression: string, selectionPath: MathStepsPath): MathStepsOperation[]`
  - Возвращает операции, дополненные:
    - `category: string` (предметная категория),
    - `order: number` (детерминированный порядок),
    - `description: string` (описание правила на русском).
- `apply(expression: string, selectionPath: MathStepsPath, operationId: string): MathStepsTransformPreview`.

`ExpressionDisplay` (поведение):
- `render(exprString: string, rootNode: MathStepsNode, options?: { pretty: boolean })`.
- Рендерит «как в учебнике» при `pretty: true`.

### 6.3 UX / настройки
- Список операций сортируется по категории (см. 7), внутри категории — по `order`, затем по `name`.
- Режимов simplify/solve нет; операции берутся автоматически из обоих доменов.
- При вводе пользователь использует технический формат; при рендере отображается учебная запись.
- В панели команд показывать `description` (RU) под названием операции.
- Для операций solve показывать локальные предположения прямо в панели команд (чекбоксы).

### 6.4 Безопасность
- Нет выполнения пользовательского кода; только парсинг mathjs.
- Ошибки парсинга приводят к безопасному сообщению пользователю.
- Для solve: операции применяются только если mathsteps разрешает трансформацию (нельзя вручную добавить потенциально некорректные шаги).

## 7. Бизнес-правила / Алгоритмы

### 7.1 Категории операций
Категории (и порядок категорий в UI):
1) Арифметика
2) Упрощения
3) Дроби
4) Степени и корни
5) Преобразования (распределение/сбор)
6) Функции
7) Уравнения

Маппинг `changeType` → категория:
- Арифметика: `SIMPLIFY_ARITHMETIC`
- Упрощения: `DIVISION_BY_NEGATIVE_ONE`, `DIVISION_BY_ONE`, `MULTIPLY_BY_ZERO`, `REARRANGE_COEFF`, `REDUCE_EXPONENT_BY_ZERO`, `REDUCE_ZERO_NUMERATOR`, `REMOVE_ADDING_ZERO`, `REMOVE_EXPONENT_BY_ONE`, `REMOVE_EXPONENT_BASE_ONE`, `REMOVE_MULTIPLYING_BY_NEGATIVE_ONE`, `REMOVE_MULTIPLYING_BY_ONE`, `RESOLVE_DOUBLE_MINUS`
- Дроби: `BREAK_UP_FRACTION`, `CANCEL_MINUSES`, `CANCEL_TERMS`, `SIMPLIFY_FRACTION`, `SIMPLIFY_SIGNS`, `FIND_GCD`, `CANCEL_GCD`, `CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION`, `IMPROPER_FRACTION_NUMERATOR`, `ADD_FRACTIONS`, `ADD_NUMERATORS`, `COMBINE_NUMERATORS`, `COMMON_DENOMINATOR`, `CONVERT_INTEGER_TO_FRACTION`, `DIVIDE_FRACTION_FOR_ADDITION`, `MULTIPLY_DENOMINATORS`, `MULTIPLY_NUMERATORS`, `MULTIPLY_FRACTIONS`
- Степени и корни: `ADD_EXPONENT_OF_ONE`, `COLLECT_CONSTANT_EXPONENTS`, `COLLECT_POLYNOMIAL_EXPONENTS`, `MULTIPLY_POLYNOMIAL_TERMS`, `EXPAND_EXPONENT`, `CANCEL_EXPONENT`, `CANCEL_EXPONENT_AND_ROOT`, `CANCEL_ROOT`, `NTH_ROOT_VALUE`, `FACTOR_INTO_PRIMES`, `GROUP_TERMS_BY_ROOT`, `CONVERT_MULTIPLICATION_TO_EXPONENT`, `DISTRIBUTE_NTH_ROOT`, `EVALUATE_DISTRIBUTED_NTH_ROOT`, `COMBINE_UNDER_ROOT`, `ADD_NTH_ROOTS`, `MULTIPLY_NTH_ROOTS`
- Преобразования: `DISTRIBUTE`, `DISTRIBUTE_NEGATIVE_ONE`, `SIMPLIFY_TERMS`, `COLLECT_AND_COMBINE_LIKE_TERMS`, `COLLECT_LIKE_TERMS`, `ADD_COEFFICIENT_OF_ONE`, `ADD_POLYNOMIAL_TERMS`, `GROUP_COEFFICIENTS`, `UNARY_MINUS_TO_NEGATIVE_ONE`, `MULTIPLY_COEFFICIENTS`, `MULTIPLY_BY_INVERSE`, `SIMPLIFY_DIVISION`
- Функции: `ABSOLUTE_VALUE`
- Уравнения: `ADD_TO_BOTH_SIDES`, `DIVIDE_FROM_BOTH_SIDES`, `MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION`, `MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE`, `MULTIPLY_TO_BOTH_SIDES`, `SIMPLIFY_LEFT_SIDE`, `SIMPLIFY_RIGHT_SIDE`, `SUBTRACT_FROM_BOTH_SIDES`, `SWAP_SIDES`, `FIND_ROOTS`, `STATEMENT_IS_TRUE`, `STATEMENT_IS_FALSE`

### 7.2 Детерминированный порядок
`order` вычисляется так:
1) порядок категории (см. выше),
2) внутри категории — фиксированный список `changeType`,
3) при равенстве — лексикографически по `operation.name`.

### 7.3 Рендер «как в учебнике»
Рендер строится из AST:
- Умножение: `*` отображается как `·` по умолчанию, допускается слипание в простых случаях (например, 2x).
- Степени: `^` отображается как верхний индекс.
- Корни: `nthRoot(x, n)` отображается как `√x` или `ⁿ√x`.
- Модуль: `abs(x)` отображается как `|x|`.
- Функции: `sin(x)`, `log(x)` и т.д. отображаются в стандартной форме.

Технический ввод сохраняется, но пользователь видит учебную форму при рендере.

### 7.4 Описания операций (RU)
Для каждого `changeType` задаётся русское описание (полное покрытие simplify + solve).
Описание хранится в таблице соответствий (ключ: `changeType`), не должно быть пропусков.
Формат описания: короткое действие, повелительное наклонение, понятное ученику.
Если mathsteps вернул неизвестный `changeType`, показывать «Неизвестное преобразование» и логировать событие.

### 7.5 Локальные предположения (solve)
Предположения задаются в панели команд рядом с операцией (вариант 1).
UI показывает список допущений (чекбоксы) только для операций solve, если они требуются.
Выбранные предположения сохраняются вместе с шагом в истории.

## 8. Точки интеграции и триггеры
- Клик по фрейму → `listOps` с `selectionPath`.
- Выбор операции → `apply` с тем же `selectionPath`.

## 9. Изменения модели данных / состояния
- `MathStepsOperation` расширяется полями `category`, `order`, `description`.

## 10. Миграция / Rollout / Rollback
- Миграция: заменить вычисление позиций фреймов по строке на рендер по AST.
- Rollback: вернуть старый `ExpressionDisplay` и string‑based позиционирование.
- Временная совместимость: оставить переключатель `pretty` как флаг, если понадобится откат визуального рендера.

## 11. Тестирование и критерии приёмки
Acceptance Criteria:
- В панели команд доступны все операции mathsteps (simplify + solve), классифицированные по категориям.
- Рендер выражения показывает учебную нотацию без потери корректности операций.
- Операции отсортированы по категориям и детерминированно повторяемы.
- Для каждой операции показано описание на русском.
- Для операций solve отображаются локальные предположения и они сохраняются в истории шага.

Unit‑тесты:
- `MathStepsEngine.listOps` возвращает `category`, `order` и `description` для всех операций.
- Проверки сортировки операций (детерминированность).
- Рендер AST → DOM: корректная разметка степеней, корней, функций, модуля.
- Сохранение корректного `selectionPath` при клике.

E2E‑тесты:
- Проверка отображения учебной нотации (x², √x, |x|).

Команды:
- `npm run test:run`
- `npm run coverage`
- `npm run build`
- `npm run test:e2e` (если изменяем UI)

## 12. Риски и edge cases
- Неполное соответствие «учебного» рендера и реального AST может привести к визуальным несоответствиям.
- Много‑буквенные переменные и функции могут конфликтовать при отображении (нужна строгая сериализация).
- Для операций solve некоторые шаги могут зависеть от допущений (деление на 0, корни чётных степеней).

## 13. План выполнения
1) Зафиксировать правила объединения simplify + solve без дедупликации, категорий и описаний.
2) Реализовать рендер из AST и измерение фреймов по DOM.
3) Добавить сортировку по категориям и описания операций.
4) Обновить/добавить unit‑тесты.
5) Прогнать unit/E2E тесты.

## 14. Открытые вопросы

## 15. Результат прогона линтера
- [PASS] 1. Есть чёткая цель.
- [PASS] 2. Описано текущее состояние (AS-IS).
- [PASS] 3. Сформулирована одна проблема.
- [PASS] 4. Цели дизайна ограничивают решение.
- [PASS] 5. Non-Goals заданы явно.
- [PASS] 6. Есть распределение ответственности.
- [PASS] 7. Явно указаны точки интеграции.
- [PASS] 8. Бизнес-логика формализована (категории, порядок, допущения для solve).
- [PASS] 9. Описана обработка ошибок.
- [PARTIAL] 10. Учтена производительность (нет оценки стоимости DOM‑измерений).
- [PASS] 11. Описаны изменения модели данных.
- [PASS] 12. Есть план миграции.
- [PASS] 13. Учтена обратная совместимость / откат.
- [PASS] 14. Есть измеримые критерии приёмки.
- [PASS] 15. Есть план тестирования.
- [PASS] 16. Есть команды для проверки.
- [PASS] 17. Есть пошаговый план.
- [PASS] 18. Нет блокирующих открытых вопросов.
- [PASS] 19. Масштаб задачи соответствует глубине спеки.
- [PASS] 20. Выполнены требования выбранного профиля.

## Approval
Ожидается фраза: "Спеку подтверждаю"
