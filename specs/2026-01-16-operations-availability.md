# Возврат недостающих операций в панели команд

## 0. Метаданные
- Тип (профиль): Проектирование подсистемы (product-system-design)
- Владелец: команда MathHelper
- Масштаб: medium
- Целевой релиз / ветка: текущая ветка
- Ограничения: не создавать новые файлы без явного указания; использовать существующие файлы проекта; не писать код до утверждения спеки
- Связанные ссылки: specs/2026-01-14-operations-revision.md

## 1. Overview / Цель
Вернуть в список доступных операций недостающие преобразования (коммутативность, дистрибуция, скобки, +0, *1) с корректной применимостью и равноправным отображением в UI.

## 2. Текущее состояние (AS-IS)
- Источник операций: `MathStepsEngine.listOps` использует `mathsteps.applicableTransforms.listApplicableTransforms` и сортировку по категориям.
- После перехода на AST-рендер часть ожидаемых операций исчезла, так как mathsteps не выдаёт коммутативность/скобки и часть преобразований на выбранных подвыражениях.
- UI показывает только то, что вернула `listOps`, без дополнительной логики применимости.

## 3. Проблема
Пользователь видит неполный набор детерминированных операций для выбранного подвыражения: отсутствуют коммутативность, дистрибуция, скобки, +0, *1, что снижает обучающую ценность и гибкость.

## 4. Цели дизайна
- Полный и применимый список операций для выбранного подвыражения.
- Равноправные операции: одинаковая модель данных, описания, превью, история.
- Проверка применимости: не показывать операции, которые не изменяют выражение.
- Сохранить текущие правила сортировки/категорий.
- Минимальная инвазивность: изменения в существующих файлах.

## 5. Non-Goals (чего НЕ делаем)
- Не добавляем новые файлы/модули без явного указания.
- Не расширяем парсер/рендер beyond текущих требований.
- Не внедряем недетерминированные или неэквивалентные преобразования.
- Не меняем структуру UI и верстку панелей.

## 6. Предлагаемое решение (TO-BE)
### 6.1 Распределение ответственности
- `MathStepsEngine`:
  - Получает операции из mathsteps.
  - Вычисляет кастомные операции при необходимости.
  - Проверяет применимость (результат должен отличаться).
  - Возвращает операции в едином формате `MathStepsOperation`.
- UI (`CommandPanel`, `ExpressionEditorApp`) остаётся потребителем списка, без логики применимости.

### 6.2 Детальный дизайн
1) Источник операций:
   - Сначала собираем операции mathsteps (как сейчас).
   - Затем добавляем кастомные операции для выбранного узла, если:
     - mathsteps не возвращает соответствующую операцию;
     - операция применима и даёт новое выражение.

2) Кастомные операции (ID и changeType в стиле `CUSTOM_*`):
   - Коммутативность:
     - Применима к `+` и `*` для узла с двумя аргументами.
     - Преобразование: обмен местами аргументов.
     - Примеры:
       - `a+b+c`, выбран `a+b` → `b+a+c`
       - `a*b*c`, выбран `b*c` → `a*c*b`
   - Дистрибуция (оба направления):
     - Раскрытие: `a*(b+c)` → `a*b+a*c`
     - Свертывание (вынесение общего множителя): `a*b+a*c` → `a*(b+c)`
     - Примеры:
       - `a*(b+c)*d`, выбран `a*(b+c)` → `(a*b+a*c)*d`
       - `a*(b+c)*d`, выбран `(b+c)*d` → `a*(b*d+c*d)`
       - `a*b+a*c`, выбран весь узел → `a*(b+c)`
       - `b*a+c*a`, выбран весь узел → `(b+c)*a`
   - Скобки:
     - Добавить: обернуть выбранный узел в `ParenthesisNode`.
     - Убрать: снять один уровень `ParenthesisNode`, если узел — скобки.
     - Примеры:
       - `a+b+c`, выбран `a+b` → `(a+b)+c`
       - `(a+b)+c`, выбран `(a+b)` → `a+b+c`
       - `((a+b))`, выбран `(a+b)` → `(a+b)`
   - +0:
     - Добавить: заменить выбранный узел на `(узел + 0)`.
     - Убрать: если узел `(+ ...)` содержит 0, заменить на другой аргумент.
     - Примеры:
       - `a+b`, выбран `a` → `(a+0)+b`
       - `a+0+b`, выбран `a+0` → `a+b`
   - *1:
     - Добавить: заменить выбранный узел на `(узел * 1)`.
     - Убрать: если узел `(* ...)` содержит 1, заменить на другой аргумент.
     - Примеры:
       - `a+b`, выбран `a` → `a*1+b`
       - `a*1+b`, выбран `a*1` → `a+b`

3) Проверка применимости:
   - Операция включается в список только если изменяет выражение.
   - No-op операции не показываются (например, “убрать скобки”, если узел не скобки).
   - Для всех операций выполняется числовая проверка эквивалентности (см. 7.1).

4) Модель данных:
   - `MathStepsOperation` для кастомных операций заполняется как для mathsteps:
     - `id` = `custom:<changeType>:<hash>`
     - `name` = короткое русское название
     - `description` = понятное объяснение на русском
     - `preview` = строка результата
     - `category` и `order` по текущим правилам
   - Операции полностью равноправны: отображаются, логируются, сохраняются в истории.

5) Обработка уравнений:
   - Кастомные операции применяются к выбранной стороне уравнения так же, как mathsteps (по `selectionPath`).

### 6.3 UX / настройки
- Все операции отображаются в общем списке.
- Кастомные операции имеют описания на русском в UI.
- Порядок сортировки остаётся прежним.

### 6.4 Безопасность
- Только детерминированные преобразования.
- Любое преобразование должно сохранять эквивалентность выражения.
- Ошибки обработки отображаются пользователю так же, как сейчас.

## 7. Бизнес-правила / алгоритмы
- Коммутативность: применяется только для `+`/`*`, два аргумента.
- Дистрибуция:
  - Раскрытие: `*` с аргументом `+`.
  - Свертывание: `+` с парой членов, имеющих общий множитель слева или справа.
- Скобки: убираются только один уровень за раз.
- +0 / *1: работают для бинарных узлов с константами 0 или 1.
- Применимость: операция должна менять строковое представление выражения.

### 7.1 Числовая проверка эквивалентности (для всех операций)
Цель: подтвердить эквивалентность преобразования при формировании списка.

Правила:
- Проверяем эквивалентность исходного выражения и результата на наборе подстановок.
- Если для точки обе стороны дают недопустимый результат (NaN/Infinity/Complex или деление на 0), точка пропускается.
- Если только одна сторона недопустима — выражения неэквивалентны.
- Требуется минимум 6 валидных точек; иначе операция считается непригодной и не показывается.
- Проверка применяется ко всем операциям, включая mathsteps.

Набор значений:
- Базовый список: `[-3, -2, -1, -0.5, 0, 0.5, 1, 2, 3, 4, 5, 10]`
- Дополнительно: `[-10, 0.1, -0.1, 100]`

Схема подстановок (без взрыва комбинаций):
- Для N переменных и M значений используем M тестов.
- Для теста `i`: переменная `v_j` получает значение `values[(i + j) mod M]`.
- Детерминированно, воспроизводимо, покрывает разные сочетания.

Сравнение чисел:
- Считаем равными, если `|a - b| <= 1e-9` или относительная ошибка `<= 1e-9`.
- Для матриц/векторов (если появятся) — поэлементно.

Применимость к уравнениям:
- Проверяем эквивалентность обеих частей (лево/право) отдельно.

## 8. Точки интеграции и триггеры
- `MathStepsEngine.listOps` — добавление кастомных операций.
- `MathStepsEngine.apply` — обработка `custom:*` id.
- `ExpressionEditorApp` — без изменений логики, использует список.

## 9. Изменения модели данных / состояния
- Новые `changeType` для кастомных операций.
- Новые `description` для этих операций.
- Формат операции остаётся прежним (`MathStepsOperation`).

## 10. Миграция / Rollout / Rollback
- Миграция: добавление кастомных операций и применения.
- Rollback: удалить ветку кастомных операций, оставить только mathsteps.
- Обратная совместимость: сохранение текущих ID и структуры `MathStepsOperation`.

## 11. Тестирование и критерии приёмки
Acceptance Criteria:
- Для указанных примеров операции доступны и дают ожидаемые результаты.
- No-op операции не отображаются.
- Кастомные операции видны в UI с описанием и превью.

Unit-тесты (в существующих файлах):
- `src/test/mathstepsEngine.test.ts`:
  - `listOps` включает коммутативность, скобки, +0, *1, дистрибуцию при выборе нужного узла.
  - `apply` для `custom:*` выдаёт ожидаемый результат.
- `src/test/naryOperations.test.ts`:
  - Проверки примеров с `a+b+c` и `a*b*c`.

E2E-тесты:
- `e2e/app.spec.ts`:
  - Коммутативность (оба примера сложения и умножения).
  - Дистрибуция (оба направления, оба примера).
  - Скобки (добавить/убрать).
  - +0 и *1 (добавить/убрать).

Команды:
- `npm run test:run`
- `npm run coverage`
- `npm run build`
- `npm run test:e2e:with-dev`

## 12. Риски и edge cases
- Сложные выражения могут дать неоднозначное вынесение множителя; требуется детерминизм.
- Для уравнений важно корректно обрабатывать `selectionPath` стороны.
- Проверка применимости должна быть быстрой и не дублировать вычисления (лимитированное число тестов, детерминированные подстановки).

## 13. План выполнения
1) Уточнить набор кастомных операций и их описания.
2) Реализовать генерацию/применение кастомных операций в `MathStepsEngine`.
3) Добавить тесты (unit + e2e) в существующих файлах.
4) Прогнать команды из раздела тестирования.

## 14. Открытые вопросы
- Нет.

## 15. Результат прогона линтера
- [PASS] 1. Есть чёткая цель.
- [PASS] 2. Описано текущее состояние (AS-IS).
- [PASS] 3. Сформулирована одна проблема.
- [PASS] 4. Цели дизайна ограничивают решение.
- [PASS] 5. Non-Goals заданы явно.
- [PASS] 6. Есть распределение ответственности.
- [PASS] 7. Явно указаны точки интеграции.
- [PASS] 8. Бизнес-логика формализована.
- [PASS] 9. Описана обработка ошибок.
- [PASS] 10. Учтена производительность (лимит тестов и детерминированная схема).
- [PASS] 11. Описаны изменения модели данных.
- [PASS] 12. Есть план миграции.
- [PASS] 13. Учтена обратная совместимость / откат.
- [PASS] 14. Есть измеримые критерии приёмки.
- [PASS] 15. Есть план тестирования.
- [PASS] 16. Есть команды для проверки.
- [PASS] 17. Есть пошаговый план.
- [PASS] 18. Нет блокирующих открытых вопросов.
- [PASS] 19. Масштаб задачи соответствует глубине спеки.
- [PASS] 20. Выполнены требования выбранного профиля.

## Approval
Ожидается фраза: "Спеку подтверждаю"
