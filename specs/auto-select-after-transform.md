# Автоматический выбор подвыражения после преобразования

## 0. Метаданные
- Тип (профиль): ui-feature-parity
- Владелец: user
- Масштаб: small
- Целевой релиз / ветка: main
- Ограничения: нет
- Связанные ссылки: нет

## 1. Overview / Цель
После применения преобразования автоматически выбирать результирующее подвыражение и показывать доступные команды для него. Это позволит применять цепочки обратимых операций (добавить +0 → убрать +0) без ручного выбора фрейма.

## 2. Текущее состояние (AS-IS)
- После выполнения команды вызывается `commandPanel.clear()` (ExpressionEditorApp.ts:206)
- Панель команд показывает placeholder "Выберите фрейм для просмотра преобразований"
- Пользователь должен вручную кликнуть на новый фрейм, чтобы увидеть доступные команды
- Это неудобно для цепочек преобразований (добавить +0, затем убрать +0)

**Текущий код:**
- `ExpressionEditorApp.ts` - главное приложение, `handleCommandClick()` обрабатывает клик на команду
- `CommandPanel.ts` - панель команд, `showCommands()` показывает команды, `clear()` очищает
- `ExpressionDisplay.ts` - отображение выражения с фреймами, обрабатывает клики на фреймы

## 3. Проблема
После применения преобразования пользователь вынужден вручную выбирать новое подвыражение, хотя путь к нему остаётся тем же. Это нарушает рабочий процесс при цепочках обратимых операций.

## 4. Цели дизайна
- Минимальные изменения в существующем коде
- Переиспользование существующей логики выбора фрейма
- Консистентное поведение с ручным кликом на фрейм

## 5. Non-Goals (чего НЕ делаем)
- Не меняем логику преобразований
- Не добавляем новые UI элементы
- Не меняем структуру данных
- Не отслеживаем "умный" путь к результату (используем тот же путь)

## 6. Предлагаемое решение (TO-BE)

### 6.1 Распределение ответственности
- `ExpressionDisplay` - добавить метод `selectFrameByPath(path)` для программного выбора фрейма
- `ExpressionEditorApp` - после применения преобразования вызывать `selectFrameByPath()` с исходным путём

### 6.2 Детальный дизайн

**Новый метод в ExpressionDisplay:**
```typescript
/**
 * Программно выбирает фрейм по пути и возвращает selection или null
 */
selectFrameByPath(path: MathStepsPath): FrameSelection | null {
  const pathKey = this.pathToKey(path);
  const frame = this.container.querySelector(`[data-path-key="${pathKey}"]`);
  if (!frame) return null;
  
  // Снять выделение с других фреймов
  document.querySelectorAll('.expression-range').forEach(f => f.classList.remove('active'));
  frame.classList.add('active');
  
  return {
    text: frame.dataset.text || '',
    path: path
  };
}
```

**Изменение в ExpressionEditorApp.handleCommandClick:**
```typescript
private handleCommandClick(operation: MathStepsOperation, assumptions: string[]): void {
  // ... существующий код применения преобразования ...
  
  this.expressionDisplay.render(newExpr, result.newNode);
  
  // Вместо commandPanel.clear() - автовыбор того же пути
  const selection = this.expressionDisplay.selectFrameByPath(operation.selectionPath);
  if (selection) {
    const operations = this.mathStepsEngine.listOps(this.currentExpression, selection.path);
    this.commandPanel.showCommands(selection, operations);
  } else {
    this.commandPanel.clear();
  }
}
```

**Обработка ошибок:**
- Если фрейм с путём не найден (структура изменилась) → очистить панель команд

**Производительность:**
- querySelector по data-атрибуту - O(n), где n - количество фреймов
- Для типичных выражений (< 50 фреймов) это незначительно

## 7. Бизнес-правила / Алгоритмы
1. После применения преобразования сохранить исходный путь `operation.selectionPath`
2. После рендеринга нового выражения найти фрейм с таким же путём
3. Если найден - выделить его и показать команды
4. Если не найден - очистить панель команд (fallback к текущему поведению)

## 8. Точки интеграции и триггеры
- `ExpressionEditorApp.handleCommandClick()` - вызывает новую логику после рендеринга
- `ExpressionDisplay.selectFrameByPath()` - новый публичный метод

## 9. Изменения модели данных / состояния
Нет изменений в модели данных. Используются существующие:
- `MathStepsPath` для идентификации пути
- `FrameSelection` для результата выбора

## 10. Миграция / Rollout / Rollback
- Изменение обратно совместимо
- Откат: вернуть вызов `commandPanel.clear()` вместо новой логики

## 11. Тестирование и критерии приёмки

**Acceptance Criteria:**
1. После применения преобразования панель команд показывает команды для результирующего подвыражения
2. Фрейм результирующего подвыражения визуально выделен (класс `active`)
3. Если структура выражения изменилась и путь недействителен - панель очищается

**Тесты для добавления:**
- Unit-тест `ExpressionDisplay.selectFrameByPath()` - возвращает selection для существующего пути
- Unit-тест `ExpressionDisplay.selectFrameByPath()` - возвращает null для несуществующего пути
- E2E тест: применить преобразование → проверить что панель команд не пустая

**Команды для проверки:**
```bash
npm run test:run
npm run test:e2e:with-dev
npm run build
```

## 12. Риски и edge cases
- **Риск:** Путь может стать недействительным после сложного преобразования
  - **Митигация:** Fallback к очистке панели команд
- **Edge case:** Корневой узел (пустой путь `[]`)
  - **Обработка:** Работает корректно, pathKey будет "root"

## 13. План выполнения
1. Добавить метод `selectFrameByPath()` в `ExpressionDisplay.ts`
2. Изменить `handleCommandClick()` в `ExpressionEditorApp.ts`
3. Написать unit-тесты для `selectFrameByPath()`
4. Написать E2E тест для автовыбора
5. Запустить все тесты и build

## 14. Открытые вопросы
Нет блокирующих вопросов.

## 15. Результат прогона линтера

### A. Полнота спеки
1. Есть чёткая цель — PASS (автовыбор подвыражения после преобразования)
2. Описано текущее состояние — PASS (раздел 2)
3. Сформулирована одна проблема — PASS (раздел 3)
4. Цели дизайна ограничивают решение — PASS (раздел 4)
5. Non-Goals заданы явно — PASS (раздел 5)

### B. Качество дизайна
6. Есть распределение ответственности — PASS (раздел 6.1)
7. Явно указаны точки интеграции — PASS (раздел 8)
8. Бизнес-логика формализована — PASS (раздел 7)
9. Описана обработка ошибок — PASS (раздел 6.2)
10. Учтена производительность — PASS (раздел 6.2)

### C. Безопасность изменений
11. Описаны изменения модели данных — PASS (нет изменений, раздел 9)
12. Есть план миграции — PASS (раздел 10)
13. Учтена обратная совместимость — PASS (раздел 10)

### D. Проверяемость
14. Есть измеримые критерии приёмки — PASS (раздел 11)
15. Есть план тестирования — PASS (раздел 11)
16. Есть команды для проверки — PASS (раздел 11)

### E. Готовность к автономной реализации
17. Есть пошаговый план — PASS (раздел 13)
18. Нет блокирующих открытых вопросов — PASS (раздел 14)
19. Масштаб задачи соответствует глубине спеки — PASS (small)

### F. Соответствие профилю
20. Выполнены требования профиля ui-feature-parity — PASS

**Итог:** ГОТОВО (нет FAIL)

## Approval
Ожидается фраза: "Спеку подтверждаю"
