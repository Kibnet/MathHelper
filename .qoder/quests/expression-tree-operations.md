# Дизайн: N-арные операции в дереве выражений

## Обзор

Текущая реализация использует строго бинарную структуру дерева для всех операций. Для коммутативных и ассоциативных операций (сложение и умножение) это создаёт неестественное представление, так как выражение `1+2+3` парсится как вложенное дерево `+(+(1, 2), 3)`.

Данная задача предусматривает переход к **n-арной** (variadic) структуре для операций сложения и умножения, где один узел оператора может иметь произвольное количество дочерних узлов (от 2 до бесконечности).

---

## Цели

1. **Изменить AST-модель**: операторы `+` и `*` должны поддерживать массив дочерних узлов произвольной длины (`children: ASTNode[]`)
2. **Адаптировать парсер**: при парсинге выражений типа `1+2+3+4` создавать один узел сложения с четырьмя детьми `[1, 2, 3, 4]`
3. **Обновить правила преобразований**: адаптировать существующие правила (коммутативность, вычисления и т.д.) для работы с n-арными узлами
4. **Модифицировать визуализацию**: создавать фреймы для всех **соседних пар** операндов в рамках одной операции

---

## Обоснование

### Математическая корректность

Сложение и умножение являются **ассоциативными** и **коммутативными** операциями:

- **Ассоциативность**: `(a + b) + c = a + (b + c)` — порядок группировки не важен
- **Коммутативность**: `a + b = b + a` — порядок элементов не влияет на результат

Благодаря этим свойствам выражение `1+2+3+4` математически эквивалентно множеству с операцией `+{1, 2, 3, 4}`, где скобки не нужны.

### Преимущества n-арной структуры

| Аспект | Бинарное дерево | N-арное дерево |
|--------|-----------------|----------------|
| **Структура для `1+2+3`** | `+(+(1, 2), 3)` — 2 узла оператора | `+(1, 2, 3)` — 1 узел оператора |
| **Глубина дерева** | O(n) для цепочки операций | O(1) для одного уровня |
| **Перестановки** | Требует реструктуризации дерева | Перестановка элементов массива |
| **Семантика** | Искусственная левоассоциативность | Естественное математическое представление |

### Недостатки и ограничения

**Не применимо к:**
- Вычитанию (`-`) — некоммутативно и неассоциативно: `(5-3)-1 ≠ 5-(3-1)`
- Делению (`/`) — аналогично вычитанию: `(8/4)/2 ≠ 8/(4/2)`

Эти операции остаются строго бинарными.

---

## Изменения в типах AST

### Текущее состояние

Файл: `src/types/index.ts`

```
export interface OperatorNode extends BaseNode {
  type: 'operator';
  value: OperatorValue;
  children: [ASTNode, ASTNode];  // Строго 2 элемента
}

export interface UnaryNode extends BaseNode {
  type: 'unary';
  value: '-';
  children: [ASTNode];
}
```

### Новая структура

N-арные операции требуют гибкого количества детей:

```
export interface OperatorNode extends BaseNode {
  type: 'operator';
  value: OperatorValue;
  children: ASTNode[];  // Массив произвольной длины (минимум 2)
}

export interface UnaryNode extends BaseNode {
  type: 'unary';
  value: '-';
  children: [ASTNode];
  implicit?: boolean;  // Скрытый унарный минус (для визуализации)
}
```

### Инварианты

- `children.length >= 2` для всех операторов
- Для операторов `+` и `*`: длина может быть любой
- Для операторов `-` и `/`: длина строго равна 2 (бинарные операции)
- `UnaryNode.implicit == true` означает, что минус был создан из оператора вычитания и должен отображаться как `-`, а не `-()`

---

## Изменения в парсере

### Текущая логика (бинарная)

Файл: `src/core/parser.ts`, метод `parseAdditive()`

Текущий алгоритм:
1. Парсится первый операнд `left`
2. В цикле: если встречается `+`, парсится правый операнд `right`
3. Создаётся узел `operator('+', [left, right])`
4. Новый узел становится `left` для следующей итерации

Результат для `1+2+3`: `+(+(1, 2), 3)` — вложенная структура

### Новая логика (n-арная)

Алгоритм для коммутативных операций (`+`, `*`):

1. Парсится первый операнд → `operands = [operand1]`
2. Запоминается первый оператор `currentOp`
3. В цикле:
   - Если следующий оператор `+` или `-` (для сложения), либо `*` или `/` (для умножения):
     - Для `+`: если встречается `-`, добавляется унарный минус вокруг следующего операнда
     - Для `*`: если встречается `/`, создаётся бинарный узел деления
   - Операнды добавляются в массив
4. Создаётся один узел: `operator(op, operands)`

**Псевдокод для сложения/вычитания:**

```
function parseAdditive():
  operands = [parseMultiplicative()]
  
  if current token is not '+' or '-':
    return operands[0]
  
  while current token is '+' or '-':
    operator = current token
    consume operator
    nextOperand = parseMultiplicative()
    
    if operator == '-':
      // Создаём скрытый унарный минус
      nextOperand = UnaryNode('-', nextOperand, implicit: true)
    
    operands.push(nextOperand)
  
  if operands.length == 1:
    return operands[0]
  else:
    return OperatorNode('+', operands)
```

**Псевдокод для умножения/деления:**

```
function parseMultiplicative():
  operands = [parseUnary()]
  
  if current token is not '*' or '/':
    return operands[0]
  
  firstOp = current operator
  
  while current token is operator:
    operator = current token
    
    // Деление остаётся бинарным
    if operator == '/' and operands.length > 1:
      // Сворачиваем накопленные операнды умножения
      left = (operands.length == 1) ? operands[0] : OperatorNode('*', operands)
      consume operator
      right = parseUnary()
      return OperatorNode('/', [left, right])
    
    if operator != firstOp:
      break
    
    consume operator
    operands.push(parseUnary())
  
  if operands.length == 1:
    return operands[0]
  else:
    return OperatorNode(firstOp, operands)
```

**Примеры:**

| Выражение | Результат AST |
|-----------|---------------|
| `1+2+3` | `+(1, 2, 3)` |
| `1+2-3` | `+(1, 2, unary_minus(3))` |
| `1-2-3` | `+(1, unary_minus(2), unary_minus(3))` |
| `a*b*c*d` | `*(a, b, c, d)` |
| `1+2*3+4` | `+(1, *(2, 3), 4)` |
| `1+2*3+4/5` | `+(1, *(2, 3), /(4, 5))` |
| `1*2/3*4/5` | `*(1, /(2, 3), /(4, 5))` |

### Обработка вычитания

**Выбранный подход: Преобразование в сложение с унарным минусом**

Выражение `1-2-3` преобразуется в `+(1, unary_minus(2), unary_minus(3))`.

Это обеспечивает:
- Единообразие с n-арной структурой сложения
- Упрощение правил коммутативности (перестановка слагаемых)
- Математическую корректность: `1-2-3 = 1+(-2)+(-3)`

**Важно:** унарный минус остаётся **скрытым** в визуализации до тех пор, пока пользователь явно не применит правило преобразования. Отображается `1-2-3`, а не `1+(-2)+(-3)`.

---

## Изменения в визуализации

### Текущее поведение

Для бинарного дерева `+(+(1, 2), 3)` создаётся 2 фрейма:
- Внутренний: `1+2`
- Внешний: `(1+2)+3`

### Новое поведение для n-арных узлов

Для узла `+(1, 2, 3)` должны создаваться фреймы для **всех соседних пар**:

| Пара | Фрейм | Содержимое |
|------|-------|------------|
| 0-1 | Пара 1 | `1+2` |
| 1-2 | Пара 2 | `2+3` |

Визуально:
```
1  +  2  +  3
└──┘  └──┘  └──┘
pair1  pair2
```

### Алгоритм создания фреймов

Для n-арного узла `operator(op, [c1, c2, ..., cn])`:

1. Создать основной фрейм для всего выражения `c1 op c2 op ... op cn`
2. Для каждой пары соседних операндов `(ci, ci+1)`:
   - Создать дополнительный фрейм `ci op ci+1`
   - Позиционировать на соответствующем уровне

**Псевдокод:**

```
function createFramesForNaryNode(node, exprString):
  if node.children.length < 2:
    return []
  
  frames = []
  
  // Основной фрейм для всего узла
  fullFrame = createFrame(node, "весь узел")
  frames.push(fullFrame)
  
  // Фреймы для соседних пар
  for i from 0 to node.children.length - 2:
    leftChild = node.children[i]
    rightChild = node.children[i + 1]
    
    pairText = extractText(leftChild) + node.value + extractText(rightChild)
    pairFrame = createFrame(virtualPairNode(leftChild, rightChild, node.value), pairText)
    
    frames.push(pairFrame)
  
  return frames
```

### Позиционирование фреймов

- **Основной фрейм**: уровень определяется глубиной узла в дереве
- **Парные фреймы**: уровень на 1 выше основного фрейма

---

## Изменения в правилах преобразований

### Коммутативность

**Упрощённая реализация** для n-арных узлов:

**Правило:** для n-арных узлов (n > 2) **НЕ генерируется** множество правил перестановки.

**Обоснование:**
- Для каждой соседней пары создаётся отдельный фрейм
- Пользователь может применить правило коммутативности к конкретной паре через её фрейм
- Генерация O(n²) правил загромождает интерфейс без пользы

**Реализация:**

```
function getCommutativeRules(node):
  if node.value != '+' and node.value != '*':
    return []
  
  // Только для бинарных узлов (внутри пар)
  if node.children.length != 2:
    return []
  
  return [{
    id: 'commutative_' + node.value,
    name: 'Поменять местами операнды',
    apply: (node) => swapChildren(node, 0, 1)
  }]
```

**Функция перестановки (только для пар):**

```
function swapChildren(node, i, j):
  newChildren = [...node.children]
  temp = newChildren[i]
  newChildren[i] = newChildren[j]
  newChildren[j] = temp
  
  return { ...node, children: newChildren, id: generateId() }
```

**Пример:** для `1+2+3` пользователь видит фреймы `1+2` и `2+3`, каждый с правилом коммутативности.

### Вычисления

**Текущая реализация** (`evaluateMultiply`, `evaluateAdd`):
- Вычисляет только для двух констант: `2 * 3 → 6`

**Новая реализация**:
- Вычисляет все последовательные константы в массиве

**Пример для `2+3+x+4+5`:**

Правила преобразования:
1. Вычислить `2+3 → 5+x+4+5`
2. Вычислить `4+5 → 2+3+x+9`
3. Вычислить все константы → `14+x` (если они становятся соседними)

**Алгоритм:**

```
function getEvaluationRules(node):
  if node.value != '+' and node.value != '*':
    return []
  
  rules = []
  
  for i from 0 to node.children.length - 2:
    left = node.children[i]
    right = node.children[i + 1]
    
    if left.type == 'constant' AND right.type == 'constant':
      rule = {
        name: "Вычислить " + left.value + node.value + right.value,
        apply: (node) => evaluatePairAt(node, i, node.value)
      }
      rules.push(rule)
  
  return rules
```

**Функция вычисления пары:**

```
function evaluatePairAt(node, index, operator):
  left = node.children[index]
  right = node.children[index + 1]
  
  result = calculate(left.value, operator, right.value)
  
  newChildren = [
    ...node.children.slice(0, index),
    { type: 'constant', value: result, id: generateId() },
    ...node.children.slice(index + 2)
  ]
  
  if newChildren.length == 1:
    return newChildren[0]
  else:
    return { ...node, children: newChildren, id: generateId() }
```

### Упрощения

**Удаление нейтральных элементов:**

| Операция | Нейтральный элемент | Пример |
|----------|---------------------|--------|
| Сложение | 0 | `1+0+2 → 1+2` |
| Умножение | 1 | `a*1*b → a*b` |

**Алгоритм:**

```
function removeNeutralElements(node):
  neutralValue = (node.value == '+') ? 0 : 1
  
  newChildren = node.children.filter(child =>
    child.type != 'constant' OR child.value != neutralValue
  )
  
  if newChildren.length == 0:
    return { type: 'constant', value: neutralValue }
  else if newChildren.length == 1:
    return newChildren[0]
  else:
    return { ...node, children: newChildren, id: generateId() }
```

**Упрощение умножения на 0:**

Правило: `a*0*b*c → 0`

```
function simplifyMultiplicationByZero(node):
  if node.value != '*':
    return null
  
  hasZero = node.children.some(child =>
    child.type == 'constant' AND child.value == 0
  )
  
  if hasZero:
    return { type: 'constant', value: 0, id: generateId() }
  else:
    return null
```

---

## Миграционная стратегия

### Этап 1: Обновление типов

1. Изменить `OperatorNode.children` на `ASTNode[]`
2. Добавить валидацию: минимум 2 элемента
3. Обновить все типовые проверки в коде

### Этап 2: Адаптация парсера

1. Реализовать n-арный парсинг для `+` и `*`
2. Сохранить бинарный парсинг для `-` и `/`
3. Добавить unit-тесты для проверки структуры AST

**Тестовые случаи:**

| Выражение | Ожидаемая структура |
|-----------|---------------------|
| `1+2` | `+(1, 2)` |
| `1+2+3` | `+(1, 2, 3)` |
| `1-2-3` | `+(1, unary_minus(2, implicit:true), unary_minus(3, implicit:true))` |
| `1+2*3+4` | `+(1, *(2, 3), 4)` |
| `1+2*3+4/5` | `+(1, *(2, 3), /(4, 5))` |
| `a*b*c*d` | `*(a, b, c, d)` |
| `a*b/c` | `*(a, /(b, c))` |

### Этап 3: Обновление правил

1. Адаптировать `getApplicableRules` для работы с массивами
2. Переписать функции преобразований:
   - `applyCommutative` → генерация множества правил
   - `evaluateMultiply/Add` → вычисление соседних пар
   - Упрощения → работа с массивами
3. Обновить тесты для правил

### Этап 4: Визуализация

1. Обновить `extractNodesFromAST` для создания парных фреймов
2. Модифицировать `calculateLabelPosition` для n-арных узлов
3. Добавить E2E-тесты для проверки отображения фреймов

**Визуальные тестовые случаи:**

| Выражение | Количество фреймов |
|-----------|--------------------|
| `1+2` | 1 (основной) |
| `1+2+3` | 3 (основной + 2 пары) |
| `1+2+3+4` | 4 (основной + 3 пары) |

### Этап 5: Обновление вспомогательных функций

Файл: `src/utils/helpers.ts`

Функции, требующие адаптации:
- `expressionToString` — обработка массива детей и флага `implicit` для унарных минусов
- `cloneNode` — клонирование массивов
- `nodesEqual` — сравнение массивов произвольной длины

**Особенность для `expressionToString`:**

```
function expressionToString(node):
  switch node.type:
    case 'operator':
      if node.value == '+':
        // Обработка скрытых унарных минусов
        parts = []
        for i, child in enumerate(node.children):
          if i == 0:
            parts.push(expressionToString(child))
          else if child.type == 'unary' and child.implicit:
            // Скрытый минус - показываем как '-'
            parts.push('-' + expressionToString(child.children[0]))
          else:
            parts.push('+' + expressionToString(child))
        return parts.join('')
      
      else if node.value == '*':
        return node.children.map(expressionToString).join(' * ')
      
      else:  // Бинарные операции - и /
        return expressionToString(node.children[0]) + ' ' + node.value + ' ' + expressionToString(node.children[1])
```

---

## Риски и ограничения

### Риск 1: Обратная совместимость

**Проблема:** Существующие тесты и код ожидают строго бинарную структуру.

**Решение:**
- Поэтапная миграция с сохранением старых тестов
- Использование TypeScript для статической проверки типов
- Промежуточные тесты для проверки совместимости

### Риск 2: Производительность

**Проблема:** Генерация множества правил и фреймов для больших выражений.

**Решение:**
- Ленивая генерация правил (по запросу)
- Кэширование вычисленных фреймов
- Ограничение визуализации (например, не более 10 операндов)

### Риск 3: Визуализация скрытых унарных минусов

**Проблема:** Пользователь вводит `1-2-3`, но AST содержит `+(1, -2, -3)`. Отображение должно показывать исходный вид.

**Решение:**
- Добавить флаг `implicit: boolean` к узлам `UnaryNode` для обозначения скрытых унарных минусов
- В функции `expressionToString` проверять флаг:
  - Если `implicit == true` → рендерить как `-` (без скобок и знака `+`)
  - Если `implicit == false` → рендерить как `-(...)` с явной нотацией
- Правило трансформации "Показать унарный минус" меняет флаг на `false`

---

## Альтернативные подходы

### Подход 1: Гибридная модель

Хранить в AST бинарную структуру, но строить n-арное представление **только для визуализации**.

**Плюсы:**
- Минимальные изменения в коде
- Обратная совместимость

**Минусы:**
- Дублирование логики
- Несоответствие между внутренней и внешней моделями

### Подход 2: Два типа узлов

Ввести отдельные типы: `BinaryOperatorNode` и `NaryOperatorNode`.

**Плюсы:**
- Явное различие в типах
- Строгая типизация

**Минусы:**
- Усложнение системы типов
- Дублирование кода для обработки

### Подход 3: Нормализация после парсинга

Парсить в бинарную структуру, затем нормализовать в n-арную.

**Плюсы:**
- Разделение ответственности
- Гибкость

**Минусы:**
- Дополнительный проход по дереву
- Сложность отслеживания tokenIds

**Выбранный подход:** прямой парсинг в n-арную структуру (основной дизайн) как наиболее семантически корректный.

---

## Критерии приёмки

1. ✅ Парсинг `1+2+3` создаёт узел `operator('+', [1, 2, 3])`
2. ✅ Парсинг `a*b*c*d` создаёт узел `operator('*', [a, b, c, d])`
3. ✅ Визуализация `1+2+3` показывает 3 фрейма: основной и 2 пары
4. ✅ Правило коммутативности доступно только для парных фреймов, а не для всего n-арного узла
5. ✅ Вычисление `2+3+x` работает корректно → `5+x`
6. ✅ Упрощение `1+0+2` → `1+2`
7. ✅ Все существующие unit-тесты проходят
8. ✅ Все E2E-тесты проходят

---

## Примеры трансформации

### Пример 1: Простое сложение

**Входное выражение:** `1+2+3`

**Текущая AST:**
```
operator('+')
├─ operator('+')
│  ├─ constant(1)
│  └─ constant(2)
└─ constant(3)
```

**Новая AST:**
```
operator('+')
├─ constant(1)
├─ constant(2)
└─ constant(3)
```

**Фреймы:**
1. Основной: `1+2+3` (без правил коммутативности на основном узле)
2. Пара 1: `1+2` (с правилом коммутативности)
3. Пара 2: `2+3` (с правилом коммутативности)

**Применение перестановок:**
- Для получения `3+2+1` из `1+2+3`: применить правило к паре `2+3` → `1+3+2`, затем к паре `1+3` → `3+1+2`, затем к паре `1+2` → `3+2+1`
- Любая перестановка достижима через последовательность перестановок соседних элементов (bubble sort)

### Пример 2: Умножение

**Входное выражение:** `a*b*c`

**Новая AST:**
```
operator('*')
├─ variable(a)
├─ variable(b)
└─ variable(c)
```

**Фреймы:**
1. Основной: `a*b*c`
2. Пара 1: `a*b` (с правилом коммутативности)
3. Пара 2: `b*c` (с правилом коммутативности)

**Применение правил через соседние пары:**
- Для перестановки `a` и `c`: сначала `a*b` → `b*a`, затем `b*c` → `c*b`, результат: `c*b*a`
- Преимущество: любая перестановка достижима через последовательные свопы соседних элементов

### Пример 3: Смешанные операции

**Входное выражение:** `1+2*3+4`

**AST:**
```
operator('+')
├─ constant(1)
├─ operator('*')
│  ├─ constant(2)
│  └─ constant(3)
└─ constant(4)
```

**Фреймы:**
1. Основной сложения: `1+2*3+4`
2. Пара 1: `1+(2*3)`
3. Пара 2: `(2*3)+4`
4. Умножение: `2*3`

### Пример 4: Вычисление

**Входное выражение:** `2+3+x+5`

**Шаг 1 — Правило "Вычислить 2+3":**
```
operator('+')
├─ constant(5)      # Результат 2+3
├─ variable(x)
└─ constant(5)
```

**Шаг 2 — После возможного переупорядочивания и правила "Вычислить 5+5":**
```
operator('+')
├─ constant(10)     # Результат 5+5
└─ variable(x)
```

**Итоговое упрощение (если только 2 элемента):**
```
operator('+')
├─ variable(x)
└─ constant(10)
```

---

## Влияние на существующий код

### Модули требующие изменений

| Файл | Требуемые изменения | Сложность |
|------|---------------------|-----------|
| `src/types/index.ts` | Изменение типа `children` | Низкая |
| `src/core/parser.ts` | Реализация n-арного парсинга | Средняя |
| `src/core/rules.ts` | Адаптация всех функций преобразований | Высокая |
| `src/core/analyzer.ts` | Генерация парных фреймов | Средняя |
| `src/utils/helpers.ts` | Работа с массивами children | Низкая |
| `src/ui/components/ExpressionDisplay.ts` | Позиционирование n-арных фреймов | Средняя |

### Тесты требующие обновления

| Тестовый файл | Тип изменений |
|---------------|---------------|
| `src/test/parser.test.ts` | Проверка n-арной структуры AST |
| `src/test/rules.test.ts` | Проверка правил только для бинарных пар |
| `src/test/helpers.test.ts` | Проверка работы с массивами children |
| `e2e/app.spec.ts` | Проверка отображения парных фреймов |

---

## Дополнительные возможности

### Расширение 1: Группировка операндов

Для длинных выражений (`1+2+3+4+5+6`) можно добавить правило группировки подмножества операндов в скобки:

**Пример:** `1+2+3+4+5` → `(1+2+3)+(4+5)`

Это создаёт вложенность в n-арной структуре.

### Расширение 2: Автоматическая оптимизация

Автоматически группировать и вычислять все последовательные константы:

**Пример:** `1+x+2+y+3` → `6+x+y`

Требует дополнительного правила "Оптимизировать всё".

### Расширение 3: Визуальные улучшения

Цветовое кодирование парных фреймов в зависимости от возможности вычисления:
- Зелёный: обе константы (можно вычислить)
- Жёлтый: одна константа
- Серый: нет констант

---

## Заключение

Переход к n-арным операциям для сложения и умножения повышает математическую корректность представления и упрощает работу с коммутативными преобразованиями. Ключевые изменения затрагивают типы AST, парсер, правила преобразований и визуализацию.

**Основные принципы:**
- Минимум 2 операнда для любого оператора
- N-арная структура только для `+` и `*`
- Создание фреймов для всех соседних пар операндов
- Генерация правил для каждой возможной перестановки

Реализация требует аккуратной поэтапной миграции с полным тестовым покрытием для обеспечения корректности на каждом этапе.
